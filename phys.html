<!DOCTYPE html>
<html lang="kk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Архимед Заңы - 3D Зертхана</title>
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            background-color: #f0f4f8; /* Lighter background */
            color: #1a202c; /* Dark text for contrast on UI if needed, but UI has own bg */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            width: 320px;
            background: rgba(255, 255, 255, 0.7); /* Lighter UI bg */
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            color: #333;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .info-card {
            background: rgba(255, 255, 255, 0.6);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .legend {
            display: flex;
            align-items: center;
            margin-top: 5px;
            font-size: 0.8rem;
            color: #555;
        }
        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        #canvas-container {
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        h1 { color: #1e40af; }
        label { color: #4b5563; }
        #massValue { color: #2563eb; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Panel -->
    <div id="ui-layer">
        <h1 class="text-2xl font-bold mb-4 text-center">Архимед Заңы</h1>
        
        <div class="slider-container">
            <label class="block text-sm font-semibold mb-1">Дене Массасы (кг)</label>
            <input type="range" id="massInput" min="1" max="20" step="0.5" value="5">
            <span id="massValue" class="float-right font-bold">5 кг</span>
        </div>

        <div class="slider-container">
            <label class="block text-sm font-semibold mb-1">Сұйықтық Тығыздығы (кг/м³)</label>
            <select id="fluidType" class="w-full p-2 rounded bg-white border border-gray-300 focus:outline-none mb-2 text-sm text-gray-700">
                <option value="1000">Су (1000 кг/м³)</option>
                <option value="920">Май (920 кг/м³)</option>
                <option value="1420">Бал (1420 кг/м³)</option>
                <option value="700">Бензин (700 кг/м³)</option>
            </select>
        </div>

        <div class="border-t border-gray-300 my-4"></div>

        <div class="info-card">
            <div class="flex justify-between mb-1">
                <span class="font-medium">Ауырлық күші (Fg):</span>
                <span id="gravityValue" class="font-mono text-red-600 font-bold">0 N</span>
            </div>
            <div class="flex justify-between">
                <span class="font-medium">Архимед күші (Fa):</span>
                <span id="buoyancyValue" class="font-mono text-green-600 font-bold">0 N</span>
            </div>
        </div>

        <div class="mt-4">
            <p class="text-xs text-gray-500 mb-2 font-semibold uppercase">Күш векторлары:</p>
            <div class="legend"><div class="dot bg-red-500"></div> Ауырлық күші (төмен)</div>
            <div class="legend"><div class="dot bg-green-500"></div> Архимед күші (жоғары)</div>
        </div>
        
        <div class="mt-4 text-center">
            <button id="resetBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-full text-sm transition shadow-lg">
                Қайта бастау
            </button>
        </div>
        
        <div class="mt-3 text-center text-xs text-gray-500 italic">
            (Текшені тінтуірмен ұстап, қозғалтыңыз)
        </div>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Setup Scene ---
        const scene = new THREE.Scene();
        // Lighter, pleasant background (Soft Blue-Grey) to remove dark contrast
        scene.background = new THREE.Color(0xeef2f5); 
        scene.fog = new THREE.Fog(0xeef2f5, 20, 100);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 12, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; 
        controls.minDistance = 5;
        controls.maxDistance = 35;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.bias = -0.001;
        scene.add(dirLight);

        // --- Environment ---
        // Floor - Soft white/grey matte floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshLambertMaterial({ 
            color: 0xffffff, 
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- The Tank (Glass) ---
        const tankWidth = 6;
        const tankHeight = 8;
        const tankDepth = 6;
        const glassThickness = 0.1;

        // Use Phong for Glass to keep it simple and clean
        const glassMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            opacity: 0.2,
            transparent: true,
            side: THREE.DoubleSide,
            shininess: 90
        });

        const tankGroup = new THREE.Group();
        
        function createWall(w, h, d, x, y, z) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, glassMaterial);
            mesh.position.set(x, y, z);
            tankGroup.add(mesh);
        }

        // Bottom
        createWall(tankWidth, glassThickness, tankDepth, 0, glassThickness/2, 0);
        // Walls
        createWall(tankWidth, tankHeight, glassThickness, 0, tankHeight/2, tankDepth/2);
        createWall(tankWidth, tankHeight, glassThickness, 0, tankHeight/2, -tankDepth/2);
        createWall(glassThickness, tankHeight, tankDepth, -tankWidth/2, tankHeight/2, 0);
        createWall(glassThickness, tankHeight, tankDepth, tankWidth/2, tankHeight/2, 0);

        scene.add(tankGroup);

        // --- The Fluid (NEW MATERIAL) ---
        const waterHeight = 6;
        
        // Changed to PhongMaterial for a nice "Game Water" look (Blue, Shiny, Transparent)
        // This eliminates the black/white refraction artifacts of PhysicalMaterial
        const fluidColor = 0x0088ff; // Bright Blue

        const waterMaterial = new THREE.MeshPhongMaterial({
            color: fluidColor,
            opacity: 0.6,
            transparent: true,
            shininess: 80,
            specular: 0x222222,
            side: THREE.DoubleSide
        });

        // 1. Fluid Volume
        const fluidVolumeGeo = new THREE.BoxGeometry(tankWidth - 0.2, waterHeight, tankDepth - 0.2);
        fluidVolumeGeo.translate(0, waterHeight/2, 0); 
        const fluidVolume = new THREE.Mesh(fluidVolumeGeo, waterMaterial);
        fluidVolume.position.y = glassThickness;
        scene.add(fluidVolume);

        // 2. Fluid Surface
        const fluidSurfaceGeo = new THREE.PlaneGeometry(tankWidth - 0.2, tankDepth - 0.2, 48, 48);
        const fluidSurface = new THREE.Mesh(fluidSurfaceGeo, waterMaterial);
        fluidSurface.rotation.x = -Math.PI / 2;
        fluidSurface.position.y = waterHeight + glassThickness;
        scene.add(fluidSurface);


        // --- The Object (Cube) ---
        const cubeSize = 2;
        const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const cubeMat = new THREE.MeshStandardMaterial({
            color: 0xffaa00,
            roughness: 0.4,
            metalness: 0.2
        });
        const cube = new THREE.Mesh(cubeGeo, cubeMat);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // --- Force Arrows ---
        const gravityArrow = new THREE.ArrowHelper(
            new THREE.Vector3(0, -1, 0),
            cube.position,
            2,
            0xdc2626, // Tailwind red-600
            0.6,
            0.4
        );
        scene.add(gravityArrow);

        const buoyancyArrow = new THREE.ArrowHelper(
            new THREE.Vector3(0, 1, 0),
            cube.position,
            0,
            0x16a34a, // Tailwind green-600
            0.6,
            0.4
        );
        scene.add(buoyancyArrow);

        // --- PARTICLE SYSTEM (Water Splash) ---
        const particleCount = 100;
        const particles = [];
        const particleGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });

        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        for(let i=0; i<particleCount; i++) {
            const mesh = new THREE.Mesh(particleGeo, particleMat);
            mesh.visible = false;
            particleGroup.add(mesh);
            particles.push({
                mesh: mesh,
                velocity: new THREE.Vector3(),
                life: 0
            });
        }

        function triggerSplash(x, z, impactForce) {
            const amount = Math.min(30, Math.floor(impactForce * 4)); 
            let spawned = 0;
            for(let i=0; i<particleCount; i++) {
                if(particles[i].life <= 0) {
                    particles[i].life = 1.0;
                    particles[i].mesh.visible = true;
                    particles[i].mesh.position.set(
                        x + (Math.random() - 0.5) * cubeSize, 
                        waterHeight, 
                        z + (Math.random() - 0.5) * cubeSize
                    );
                    particles[i].velocity.set(
                        (Math.random() - 0.5) * 2, 
                        Math.random() * 2 + impactForce * 0.4, 
                        (Math.random() - 0.5) * 2
                    );
                    spawned++;
                    if(spawned >= amount) break;
                }
            }
        }


        // --- Physics Variables ---
        let gravity = 9.8; 
        let fluidDensity = 1000;
        let objectMass = 5; 
        const scaleFactor = 0.1; 
        const realVolume = Math.pow(cubeSize * scaleFactor, 3);

        // Position & Velocity
        let posY = 10;
        let velY = 0;
        const dt = 1/60;
        
        let wasSubmerged = false; 
        let currentWaterLevel = waterHeight; 

        // --- INTERACTION / DRAGGING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane();
        const planeIntersect = new THREE.Vector3();
        let isDragging = false;
        let dragOffset = new THREE.Vector3();

        const canvasEl = renderer.domElement;

        canvasEl.addEventListener('pointerdown', onPointerDown);
        canvasEl.addEventListener('pointermove', onPointerMove);
        canvasEl.addEventListener('pointerup', onPointerUp);
        canvasEl.addEventListener('pointerleave', onPointerUp); 

        function onPointerDown(event) {
            const rect = canvasEl.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(cube);

            if (intersects.length > 0) {
                isDragging = true;
                controls.enabled = false; 

                const normal = new THREE.Vector3();
                camera.getWorldDirection(normal).negate(); 
                dragPlane.setFromNormalAndCoplanarPoint(normal, cube.position);

                if (raycaster.ray.intersectPlane(dragPlane, planeIntersect)) {
                    dragOffset.subVectors(cube.position, planeIntersect);
                }
                
                velY = 0;
            }
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            const rect = canvasEl.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (raycaster.ray.intersectPlane(dragPlane, planeIntersect)) {
                let newPos = new THREE.Vector3().addVectors(planeIntersect, dragOffset);
                
                const limitX = (tankWidth / 2) - glassThickness - (cubeSize / 2);
                const limitZ = (tankDepth / 2) - glassThickness - (cubeSize / 2);
                
                newPos.x = Math.max(-limitX, Math.min(limitX, newPos.x));
                newPos.z = Math.max(-limitZ, Math.min(limitZ, newPos.z));

                if (newPos.y < cubeSize / 2 + glassThickness) {
                    newPos.y = cubeSize / 2 + glassThickness;
                }
                
                cube.position.copy(newPos);
                posY = cube.position.y;
            }
        }

        function onPointerUp() {
            if (isDragging) {
                isDragging = false;
                controls.enabled = true;
            }
        }


        // --- DOM Elements ---
        const massInput = document.getElementById('massInput');
        const massDisplay = document.getElementById('massValue');
        const fluidSelect = document.getElementById('fluidType');
        const gravityDisplay = document.getElementById('gravityValue');
        const buoyancyDisplay = document.getElementById('buoyancyValue');
        const resetBtn = document.getElementById('resetBtn');

        // --- Update Functions ---
        function updateParameters() {
            objectMass = parseFloat(massInput.value);
            massDisplay.textContent = objectMass + " кг";
            fluidDensity = parseFloat(fluidSelect.value);

            let newColor;
            if(fluidDensity === 1000) newColor = 0x0088ff; // Water Blue
            else if(fluidDensity === 920) newColor = 0xeab308; // Oil Yellow
            else if(fluidDensity === 1420) newColor = 0xd97706; // Honey Amber
            else newColor = 0xef4444; // Gasoline Red

            fluidVolume.material.color.setHex(newColor);
            fluidSurface.material.color.setHex(newColor);
        }

        massInput.addEventListener('input', updateParameters);
        fluidSelect.addEventListener('change', updateParameters);
        
        resetBtn.addEventListener('click', () => {
            posY = 10;
            velY = 0;
            cube.position.set(0, 10, 0); 
            massInput.value = 5;
            fluidSelect.value = "1000";
            updateParameters();
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.003;
            
            // --- Physics & Logic ---
            if (!isDragging) {
                const halfWidth = (tankWidth - 0.2) / 2;
                const halfDepth = (tankDepth - 0.2) / 2;
                const insideTank = (Math.abs(cube.position.x) < halfWidth && Math.abs(cube.position.z) < halfDepth);

                const cubeBottom = posY - cubeSize / 2;
                const cubeTop = posY + cubeSize / 2;
                
                currentWaterLevel = waterHeight; 

                let submergedRatio = 0;
                if (insideTank) {
                    if (cubeBottom < currentWaterLevel) {
                        if (cubeTop < currentWaterLevel) {
                            submergedRatio = 1; 
                        } else {
                            const submergedHeight = currentWaterLevel - cubeBottom;
                            submergedRatio = submergedHeight / cubeSize;
                        }
                    }
                }
                if (cubeBottom > currentWaterLevel) submergedRatio = 0;

                const isSubmerged = submergedRatio > 0;
                if (isSubmerged && !wasSubmerged && velY < -2) {
                    triggerSplash(cube.position.x, cube.position.z, Math.abs(velY));
                }
                wasSubmerged = isSubmerged;

                const F_gravity = objectMass * gravity;
                const visualVolumeMultiplier = 1.0; 
                
                const F_buoyancy = fluidDensity * (realVolume * visualVolumeMultiplier * submergedRatio) * gravity;
                let netForce = F_buoyancy - F_gravity;

                let damping = 0.98; 
                if (submergedRatio > 0) damping = 0.90; 
                
                const acceleration = netForce / objectMass;

                velY += acceleration * dt;
                velY *= damping;
                posY += velY * dt;

                let floorLevel = 0.1; 
                if (insideTank) floorLevel = glassThickness + 0.1;
                
                if (posY < cubeSize / 2 + floorLevel) {
                    posY = cubeSize / 2 + floorLevel;
                    velY *= -0.3;
                    cube.position.x *= 0.95; 
                    cube.position.z *= 0.95;
                }

                cube.position.y = posY;

                gravityDisplay.textContent = F_gravity.toFixed(1) + " N";
                buoyancyDisplay.textContent = F_buoyancy.toFixed(1) + " N";

                gravityArrow.position.copy(cube.position);
                gravityArrow.setLength(objectMass * 0.3, 0.5, 0.3);

                buoyancyArrow.position.copy(cube.position);
                const buoyancyLength = (F_buoyancy / gravity) * 0.3; 
                buoyancyArrow.setLength(Math.max(0.001, buoyancyLength), 0.5, 0.3);

                if(submergedRatio > 0 && submergedRatio < 1) {
                    const waveAtCenter = Math.sin(time) * 0.05;
                    cube.rotation.x = waveAtCenter; 
                    cube.rotation.z = Math.cos(time * 0.8) * 0.05;
                } else {
                    cube.rotation.x *= 0.9;
                    cube.rotation.z *= 0.9;
                }
            } else {
                wasSubmerged = false; 
                gravityArrow.position.copy(cube.position);
                buoyancyArrow.position.copy(cube.position);
            }

            // --- Water & Particle Animation ---
            for(let i=0; i<particleCount; i++) {
                if(particles[i].life > 0) {
                    particles[i].life -= 0.02;
                    particles[i].velocity.y -= 0.1;
                    particles[i].mesh.position.add(particles[i].velocity.multiplyScalar(0.05));
                    if(particles[i].mesh.position.y < currentWaterLevel) particles[i].life = 0;
                    particles[i].mesh.opacity = particles[i].life;
                    if(particles[i].life <= 0) particles[i].mesh.visible = false;
                }
            }

            const positionAttribute = fluidSurface.geometry.attributes.position;
            for ( let i = 0; i < positionAttribute.count; i ++ ) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i); 
                const waveHeight = Math.sin(x * 2 + time) * 0.05 + Math.cos(y * 1.5 + time) * 0.05;
                positionAttribute.setZ(i, waveHeight);
            }
            positionAttribute.needsUpdate = true;
            fluidSurface.geometry.computeVertexNormals();


            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateParameters();
        animate();

    </script>
</body>
</html>
